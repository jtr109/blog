<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>tech on jtr109&#39;s Castle</title>
    <link>https://jtr109.github.io/categories/tech/</link>
    <description>Recent content in tech on jtr109&#39;s Castle</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 07 Jan 2020 23:45:24 +0000</lastBuildDate>
    
	<atom:link href="https://jtr109.github.io/categories/tech/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>一次性密码</title>
      <link>https://jtr109.github.io/posts/one-time-password/</link>
      <pubDate>Tue, 07 Jan 2020 23:45:24 +0000</pubDate>
      
      <guid>https://jtr109.github.io/posts/one-time-password/</guid>
      <description>背景 很多大型网站都提供了一种动态数字密码作为两步认证（2FA）的方案。你只要通过常用的密码管理器（例如 1Password，Authy 等）扫描二维码，就可以获得一个动态数字 token。我们来一起探索一下这门技术。
TOTP TOTP 即 Time-Based One-Time Password Algorithm。顾名思义这是一种基于时间的 token 算法，从宏观来看就是基于时间和共享的密钥（shared secret key）生成随机数字 token。
与之类似的算法还有HOTP（Event-Based One-Time Password Algorithm）。
Google Authenticator Google Authenticator 也是一种 TOTP，只不过它的 secret key 必须使用 base32 的1。
Rust Implement  Google Authenticator Rust：一个非常简介易用的 crate，但是示例都存在着一些问题，可用示例可以参考我的 fork2； rust-oath：使用数最多的相关 crate，功能全面；  Have A Try  在项目中尝试了生成 secret （secret.rs），生成二维码（qr_code.rs）以及生成 token（code.rs）。  Reference       Google Authenticator 的特殊性参考这个项目中的说明 &amp;#x21a9;&amp;#xfe0e;
 已提交 pull request &amp;#x21a9;&amp;#xfe0e;
   </description>
    </item>
    
    <item>
      <title>Rust Recommanded Project Structure</title>
      <link>https://jtr109.github.io/posts/rust-recommanded-project-structure/</link>
      <pubDate>Mon, 06 Jan 2020 22:51:41 +0000</pubDate>
      
      <guid>https://jtr109.github.io/posts/rust-recommanded-project-structure/</guid>
      <description>Background The Cargo Book recommand the package layout of rust project. Here is an example project implemented with it.
. ├── Cargo.lock ├── Cargo.toml ├── benches │ └── large-input.rs ├── examples │ └── simple.rs ├── src │ ├── bin │ │ └── another_executable.rs │ ├── lib.rs │ └── main.rs └── tests └── some-integration-tests.rs Lib The elements want be used outside should start with pub (which means publish) in src/lib.rs.
pub fn hello(s: &amp;amp;str) -&amp;gt; String { format!</description>
    </item>
    
    <item>
      <title>Rust Serde Json</title>
      <link>https://jtr109.github.io/posts/rust-serde-json/</link>
      <pubDate>Tue, 24 Dec 2019 23:34:10 +0000</pubDate>
      
      <guid>https://jtr109.github.io/posts/rust-serde-json/</guid>
      <description>背景 今天学习 The Rust Cookbook 的时候看到一段 JSON 解码的代码:
#[macro_use] extern crate serde_json; use serde_json::{Value, Error}; fn main() -&amp;gt; Result&amp;lt;(), Error&amp;gt; { let j = r#&amp;#34;{ &amp;#34;userid&amp;#34;: 103609, &amp;#34;verified&amp;#34;: true, &amp;#34;access_privileges&amp;#34;: [ &amp;#34;user&amp;#34;, &amp;#34;admin&amp;#34; ] }&amp;#34;#; let parsed: Value = serde_json::from_str(j)?; let expected = json!({ &amp;#34;userid&amp;#34;: 103609, &amp;#34;verified&amp;#34;: true, &amp;#34;access_privileges&amp;#34;: [ &amp;#34;user&amp;#34;, &amp;#34;admin&amp;#34; ] }); assert_eq!(parsed, expected); Ok(()) } 疑问 这里衍生出一个问题: &amp;ldquo;变量 expected 被一个宏 json! 的结果赋值, 那这个 expected 到底是什么类型?&amp;rdquo;
查看文档可以了解到这是一个 serde_json::value::Value.</description>
    </item>
    
    <item>
      <title>Export or Not Export in Environment File</title>
      <link>https://jtr109.github.io/posts/export-or-not-in-env-file/</link>
      <pubDate>Tue, 10 Dec 2019 11:00:25 +0000</pubDate>
      
      <guid>https://jtr109.github.io/posts/export-or-not-in-env-file/</guid>
      <description>背景 在项目中需要使用 envsubst 从模板生成配置文件. 发现如果在环境变量文件 env.conf (或 .env 等) 中不使用 export 命令, envsubst 无法获取到所需的环境变量.
实验 构建模板文件 src.txt
now foo here: ${FOO}  不使用 export 创建环境变量配置文件 env.conf:
FOO=bar 创建执行脚本 subenv.sh:
source env.conf echo $FOO envsubst &amp;lt; &amp;#34;src.txt&amp;#34; &amp;gt; &amp;#34;env-tar.txt&amp;#34; 执行脚本 [subenv.sh](http://subenv.sh) 查看生成的 env-tar.txt 文件:
now foo here:  使用 export 创建环境变量配置文件 exp.conf
export FOO=bar 创建执行脚本 subexp.sh:
source exp.conf echo $FOO envsubst &amp;lt; &amp;#34;src.txt&amp;#34; &amp;gt; &amp;#34;exp-tar.txt&amp;#34; 执行脚本 [subexp.sh](http://subexp.sh) 查看生成文件 exp-tar.txt:
now foo here: bar  可以看到, 在环境变量配置文件中使用 export, 在脚本中使用 envsubst 才能获取到所需的环境变量.</description>
    </item>
    
    <item>
      <title>计算机相关时间规则和表示方法</title>
      <link>https://jtr109.github.io/posts/datetime-note/</link>
      <pubDate>Sat, 07 Dec 2019 22:02:45 +0000</pubDate>
      
      <guid>https://jtr109.github.io/posts/datetime-note/</guid>
      <description>ISO 指的是什么? 关于时间, 我们说的 ISO 一般是指 ISO 8601
ISO 8601 主要定义了时区0点的规则, 消除各种时间的表达方法. 我们可以在 wiki 页面查看到当前时间的表达法示例:
   Name Display     Date 2019-12-08   Date and time in UTC 2019-12-08T01:24:12+00:002019-12-08T01:24:12Z20191208T012412Z   Week 2019-W49   Date with week number 2019-W49-7   Date without year &amp;ndash;12-08   Ordinal date 2019-342    标准时区 根据 Wiki 上的描述:
 In general, ISO 8601 applies to representations and formats of dates in the Gregorian (and potentially proleptic Gregorian) calendar, of times based on the 24-hour timekeeping system (with optional UTC offset), of time intervals, and combinations thereof.</description>
    </item>
    
    <item>
      <title>Pip Install From Git Repositories</title>
      <link>https://jtr109.github.io/posts/about-pip-install/</link>
      <pubDate>Wed, 27 Nov 2019 17:27:14 +0000</pubDate>
      
      <guid>https://jtr109.github.io/posts/about-pip-install/</guid>
      <description>包安装 问题 在公司项目开发过程中, 我们构建了一些自定义的 Python packages. 如果直接使用如下方式安装, 可以正常使用, 但是 pip freeze 的时候只会显示包名称和版本. 无法在实际生产中使用.
$ pip install git+https://git.example.com/example/foo.git ... $ pip freeze &amp;gt; requirements.txt $ cat requirements.txt dm-utils==1.0 解决方案 需要参考这个 issue实现:
$ pip install -e git+https://git.example.com/example/foo.git#egg=0.0.1 $ pip freeze &amp;gt; requirements.txt $ cat requirements.txt -e git+https://git.example.com/example/foo.git@2c2ed2b3df2084d1b1ebfa87c9fe703072eded7b#egg=dm_utils Docker Build 上面的示例可以解决大部分 public 项目的拉取和安装问题, 但如果在 private 项目中使用上面的方案, 在 docker build 时会报错, 原因是构建镜像的时候, 镜像中没有我们的 git 用户信息, 无法拉取私有仓库.
需要向项目仓库所有者请求一个 deploy token, 使用提供的用户名和 token 执行 pip install, 例如:</description>
    </item>
    
    <item>
      <title>在 Git 托管服务中使用两步验证能力</title>
      <link>https://jtr109.github.io/posts/git-with-2fa/</link>
      <pubDate>Thu, 14 Nov 2019 14:06:16 +0000</pubDate>
      
      <guid>https://jtr109.github.io/posts/git-with-2fa/</guid>
      <description>写在最前 作为开发者, 应该清楚地知道 &amp;ldquo;密码再强也不是不可能被破解&amp;rdquo;, 所以只要网站支持 2FA, 就建议在自己的帐号中配置 2FA 支持.
在 GitLab 中使用 2FA GitLab 中如何开启 2FA 在文档中写得比较清晰, 而且其中推荐了几种可选的 one time password authenticators.
但是按照这个方案操作完之后, 如果你的项目通过 https 指定远程 git 仓库地址, 你的 git 终端会要求你重新登录. 如果你足够耐心, 其实可以在页面下方找到解决方案.
 When 2FA is enabled, you can no longer use your normal account password to authenticate with Git over HTTPS on the command line or when using GitLab’s API. You must use a personal access token instead.</description>
    </item>
    
    <item>
      <title>Django `get_or_create` 创建重复条目问题分析和处理</title>
      <link>https://jtr109.github.io/posts/race-condition-when-using-django-get-or-create/</link>
      <pubDate>Sat, 09 Nov 2019 22:09:45 +0000</pubDate>
      
      <guid>https://jtr109.github.io/posts/race-condition-when-using-django-get-or-create/</guid>
      <description>名词解释  Data Race &amp;amp; Race Condition: 待补充, 可参考这个 StackOverflow 回答  问题描述 Django 的 ORM 操作中有一个非常实用的功能: get_or_create, 可以判断数据库中是否有符合条件的条目, 没有则创建.
但是在使用过程中如果不加留意, 会发生 race condition. 导致数据库中创建出的条目不符合预期.
以下面这部分代码为例:
# models.py class Race(models.Model): user_id = models.CharField(max_length=32) name = models.CharField(max_length=32) 如果在项目中调用遇到了并发的情况, 会导致数据库中有一条以上的相同条目. 可以编写单元测试复现该问题:
# tests.py class RaceTestCase(TestCase): def test_race(self): def get_or_create(): Race.objects.get_or_create( user_id=&amp;#39;c53b8ba212ef4f15b2365e1bb3d524fe&amp;#39;, defaults=dict(name=&amp;#39;foo&amp;#39;, age=1), ) threads = list() for _ in range(10): threads.append(threading.Thread(target=get_or_create)) for t in threads: t.start() for t in threads: t.join() self.</description>
    </item>
    
  </channel>
</rss>