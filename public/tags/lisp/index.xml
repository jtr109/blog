<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LISP on jtr109&#39;s Castle</title>
    <link>https://jtr109.github.io/tags/lisp/</link>
    <description>Recent content in LISP on jtr109&#39;s Castle</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 28 Nov 2017 07:52:09 +0800</lastBuildDate>
    
	<atom:link href="https://jtr109.github.io/tags/lisp/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>LISP 中的各种相等表示</title>
      <link>https://jtr109.github.io/posts/equal-in-lisp/</link>
      <pubDate>Tue, 28 Nov 2017 07:52:09 +0800</pubDate>
      
      <guid>https://jtr109.github.io/posts/equal-in-lisp/</guid>
      <description>简述 LISP 中描述相等的断言主要有 eq, eql, equal 和 equalp. 他们对应的判断条件各不相同.
逐个分析 断言 eq (eq x y) 仅当 x 和 y 是同一对象时才返回 true</description>
    </item>
    
    <item>
      <title>Yet Another Scheme Tutorial 学习笔记</title>
      <link>https://jtr109.github.io/posts/yast-learning/</link>
      <pubDate>Wed, 23 Aug 2017 07:30:11 +0800</pubDate>
      
      <guid>https://jtr109.github.io/posts/yast-learning/</guid>
      <description>算数操作 基本算数操作  函数 exact-&amp;gt;inexact 用于把分数转换为浮点数. 函数 quotient 用于求商数（quotient）。 函数 remainder 和 modulo 用于求余数（remainder）。 函数 sqrt 用于求参数的平方根（square root）。  (exact-&amp;gt;inexact (/ 29 3 7)) ;-&amp;gt; 1.380952380952381 (quotient 7 3) ;→ 2 (modulo 7 3) ;→ 1 (sqrt 8) ;→ 2.8284271247461903 练习 练习中发现, 如果创建 scm 文件并写入多个算式, 好像不能得出每个计算的值, 得到的只能是最后一个算式的结果.
表 空表 &#39;() 即为空表
有两种非常类似的 value, 实现的方式却是不同的:
 (3 2 . 1):  (1 2 3):   其实主要的差异是最后一个 cons 的 cdr 指向地址的不同, 上面一个是指向 1 所在的地址, 最后一个是指向一个空表 &#39;()</description>
    </item>
    
    <item>
      <title>SICP 学习摸索</title>
      <link>https://jtr109.github.io/posts/sicp-learning/</link>
      <pubDate>Wed, 23 Aug 2017 06:58:42 +0800</pubDate>
      
      <guid>https://jtr109.github.io/posts/sicp-learning/</guid>
      <description>以前学习过 MIT 6.00.1X, 也可以算是 SICP 的 Python 版. 在最近的开始的 SICP 学习中, 发现对 scheme 语法几乎为零, 用到再学的思路遇到了补上坎. 经常为了研究语法而打断思路. 所以工欲善其事, 必先利其器. 现在先暂停 SICP 的学习.
在网上可以很方便地找到这样一些关于 SICP 的有用资源, 在这里做一下罗列.
 SICP 解题集: 非常不错的中文解题集项目, 目前可能已经不维护, 有一些地方得不到更新, 需要的同学可以在项目 issue 中查找和添加相关问题, 不过现有资源也非常值得学习了. SICP 公开课中文化项目: 翻译了完整的 SICP 课程视频, 可以说是一个伟大的项目. 也是目前结合 SICP 学习的优秀素材. Scheme 入门教程: 也是公开课中文化项目的维护者 DeathKing 的翻译项目, 目前刚刚开始学习.  </description>
    </item>
    
    <item>
      <title>SICP 学习笔记 (一)</title>
      <link>https://jtr109.github.io/posts/sicp-note-1/</link>
      <pubDate>Sat, 19 Aug 2017 07:38:15 +0800</pubDate>
      
      <guid>https://jtr109.github.io/posts/sicp-note-1/</guid>
      <description>目前从 1.2 开始做笔记, 之前的可能会, 也可能不会补上.
1.2 1.2.1 线性的递归和迭代  在各种常见语言的大部分实现的设计中, 对于任何递归过程的解释, 所消耗的存储量总与过程调用 数目成正比, 即使它所描述的计算过程从原理上来看是迭代的.
 大部分语言中, 书写形式是递归, 但是处理逻辑是迭代的.
练习 1.9 # 题干 (define (+ a b) (if (= a 0) b (inc (+ (dec a) b)))) (define (+ a b) (if (= a 0) b (+ (dec a) (inc b)))) # 计算 (+ 4 5) # 计算过程是递归的或者迭代的吗 # 定义1 (+ 4 5) (inc (+ 3 5)) (inc (inc (+ 2 5))) (inc (inc (inc (+ 1 5)))) (inc (inc (inc (inc (+ 0 5))))) (inc (inc (inc (inc 5)))) (inc (inc (inc 6))) (inc (inc 7)) (inc 8) 9 # 结论: 以上递归过程属于线性递归计算过程 # 定义 2 (+ 4 5) (+ 3 6) (+ 2 7) (+ 1 8) (+ 0 9) 0 # 结论: 以上递归过程属于线性迭代计算过程 引用 SICP 习题集 中的话:</description>
    </item>
    
  </channel>
</rss>